expressions: dict[str, list[str]] = {
    "Assign": ["name: Token", "value: Expr"],
    "Binary": ["left: Expr", "operator: Token", "right: Expr"],
    "Call": ["callee: Expr", "paren: Token", "arguments: tuple[Expr, ...]"],
    "Get": ["obj: Expr", "name: Token"],
    "Grouping": ["expression: Expr"],
    "Literal": ["value: Any"],
    "Logical": ["left: Expr", "operator: Token", "right: Expr"],
    "Set": ["obj: Expr", "name: Token", "value: Expr"],
    "Super": ["keyword: Token", "method: Token"],
    "Ternary": [
        "operator: Token",
        "first: Expr",
        "second: Expr",
        "third: Expr",
    ],
    "This": ["keyword: Token"],
    "Unary": ["operator: Token", "right: Expr"],
    "Variable": ["name: Token"],
}

statements: dict[str, list[str]] = {
    "BlockStmt": ["statements: tuple[Stmt, ...]"],
    "ClassStmt": [
        "name: Token",
        "superclass: Variable | None",
        "methods: tuple[FunctionStmt, ...]",
    ],
    "ExpressionStmt": ["expression: Expr"],
    "FunctionStmt": [
        "name: Token",
        "params: tuple[Token, ...]",
        "body: tuple[Stmt, ...]",
    ],
    "IfStmt": ["condition: Expr", "then_branch: Stmt", "else_branch: Stmt"],
    "PrintStmt": ["expression: Expr"],
    "ReturnStmt": ["keyword: Token", "val: Expr | None"],
    "VarStmt": ["name: Token", "initializer: Expr"],
    "WhileStmt": ["condition: Expr", "body: Stmt"],
}

setup_lines = """# Autogenerated by gen_ast.py
from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any

from parsing.tokens import Token


class Expr(ABC):
    @abstractmethod
    def accept(self, visitor: ExprVisitor):
        raise NotImplementedError


class Stmt(ABC):
    @abstractmethod
    def accept(self, visitor: StmtVisitor):
        raise NotImplementedError
"""


class AstGenerator:
    def __init__(self) -> None:
        self.lines: list[str] = [setup_lines]

    def gen_visitors(self, name: str, specs: dict[str, list[str]]):
        self.lines.append(f"\n\nclass {name}Visitor(ABC):")
        for expr in specs:
            self.lines.append(
                "\n    @abstractmethod\n"
                f"    def visit_{expr.lower()}(self, {name.lower()}: {expr}):"
                "\n        raise NotImplementedError\n"
            )

    def gen_ast(self, name: str, specs: dict[str, list[str]]):
        for expr, fields in specs.items():
            expr_definition = (
                "\n\n@dataclass(eq=False, frozen=True)\n"
                f"class {expr}({name}):\n"
            )
            for field in fields:
                expr_definition += f"    {field}\n"
            expr_definition += (
                f"\n    def accept(self, visitor: {name}Visitor):"
                f"\n        return visitor.visit_{expr.lower()}(self)\n"
            )
            self.lines.append(expr_definition)

    def output(self, filename):
        with open(filename, "w") as file:
            file.write("".join(self.lines))


if __name__ == "__main__":
    generator = AstGenerator()
    generator.gen_visitors("Expr", expressions)
    generator.gen_visitors("Stmt", statements)
    generator.gen_ast("Expr", expressions)
    generator.gen_ast("Stmt", statements)
    generator.output("ast_defs.py")
